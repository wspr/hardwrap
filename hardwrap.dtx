% \iffalse
%
%<*internal>
\begingroup
%</internal>
%<*batchfile>
\input docstrip.tex
\keepsilent
\preamble
  ____________________________
  The HARDWRAP package
  (C) 2010 Will Robertson
  (C) 2010 Kevin Godby
  License information appended

\endpreamble
\postamble

Copyright (C) 2010 by Will Robertson <will.robertson@latex-project.org>
Copyright (C) 2010 by Kevin Godby <godbyk@gmail.com>

Distributable under the LaTeX Project Public License,
version 1.3c or higher (your choice). The latest version of
this license is at: http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status)
by Will Robertson.

This work consists of the file  hardwrap.dtx
          and the derived files hardwrap.sty,
                                hardwrap.ins, and
                                hardwrap.pdf.

\endpostamble
\askforoverwritefalse
\generate{\file{hardwrap.sty}{\from{hardwrap.dtx}{package}}}
%</batchfile>
%<batchfile>\endbatchfile
%<*internal>
\generate{\file{hardwrap.ins}{\from{hardwrap.dtx}{batchfile}}}
\def\tmpa{plain}
\ifx\tmpa\fmtname\endgroup\expandafter\bye\fi
\endgroup
%</internal>
%
%    \begin{macrocode}
%<*driver>
\ProvidesFile{hardwrap.dtx}
%</driver>
%<package>\ProvidesPackage{hardwrap}
%<*package>
  [2010/10/02 v0.1 Hard wrap messages]
%</package>
%    \end{macrocode}
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{xcolor,hardwrap,lipsum,booktabs}
\linespread{1.05}      % A bit more space between lines
\frenchspacing         % Remove extra space after punctuation
\definecolor{niceblue}{rgb}{0.1,0.2,1}
\def\theCodelineNo{\textcolor{niceblue}{\sffamily\tiny\arabic{CodelineNo}}}
\newcommand*\pkg[1]{\textsf{#1}}
\newcommand*{\earg}[1]{{\ttfamily\char`\{}\texttt{#1}{\ttfamily\char`\}}}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
%
% \fi
%
% \errorcontextlines=999
% \makeatletter
%
% ^^A TESTING:
% \GeneratePackageLogMacros{hardwrap}
% \hardwrap@warning{Terminal spaces used to cause an infinite loop! No more }
% \hardwrap@warning{\space Testing\space\space\space spaces.\space}
% \hardwrap@warning{Hello! This is an example of the hardwrap logging macro. Let us hope that it works properly and wraps our text to just the right length. (These words should reach all the way until the end of TeX's hard-wrapped log file output.) If not, panic!}
%
% ^^A CONTINUE:
%
% \GetFileInfo{\jobname.dtx}
%
% \title{The \pkg{\jobname} package}
% \author{Kevin Godby \and Will Robertson}
% \date{\filedate \qquad \fileversion}
%
% \maketitle
%
% \section{Introduction}
%
% The \pkg{\jobname} package provides a macro for word-wrapping text.  In
% addition, helper macros are available for package and document class authors
% to use in automatically wrapping informational, warning, and error messages.
%
% \section{Wrapping text}
%
% \begin{quote}
%   \cs{hardwrap}\marg{width}\marg{function}\marg{newline}\marg{text}
% \end{quote}
%
% This command will wrap \meta{text} to a text block of \meta{width} characters
% wide, inserting \meta{newline} at the end of each line and processing the
% result with \meta{function}.
%
% \section{Wrapping log messages}
%
% A common use case for the \cs{hardwrap} macro is to format the
% informational, warning, and error messages that are printed to the terminal
% and log file.  In support of this, we've provided a simple interface for
% package and document class authors to do this.
%
% \begin{quote}
%   \cs{GeneratePackageLogMacros}\oarg{prefix}\marg{pkgname}\\
%   \cs{GenerateClassLogMacros}\oarg{prefix}\marg{clsname}
% \end{quote}
%
% If the optional argument \meta{prefix} is not given, it is set equal to \meta{pkgname}.
%
% The \cs{GeneratePackageLogMacros} macro will generate the following macros:
%
% \begin{quote}
%   \cs{\meta{prefix}@info}\marg{info}\\
%   \cs{\meta{prefix}@info@noline}\marg{info}\\
%   \cs{\meta{prefix}@warning}\marg{warning}\\
%   \cs{\meta{prefix}@warning@noline}\marg{warning}\\
%   \cs{\meta{prefix}@error}\marg{error}\marg{help}
% \end{quote}
%
% For instance, calling \cs{GeneratePackageLogMacros}\earg{mypackage}
% will create macros called \cs{mypackage@info}, \cs{mypackage@warning}, etc.
%
% The arguments for the macros are the same as the arguments for
% \cs{PackageInfo}\marg{pkgname}, \cs{PackageWarning}\marg{pkgname}, etc.  An additional macro,
% \cs{\meta{pkgname}@info@noline}, is provided which suppresses \LaTeX's
% ``\texttt{on line \meta{num}}'' suffix.
%
% Similar macros are generated by \cs{GenerateClassLogMacros} using
% \meta{clsname} as the prefix.
%
% \section{Customizing the output}
%
% While \pkg{\jobname} goes to some effort to determine the appropriate line
% lengths, you may wish to override the value.
%
% \begin{quote}
%   \cs{setmaxprintline}\marg{value}
% \end{quote}
%
% The \cs{setmaxprintline} macro takes an integer value and uses it as the
% maximum line width allowed in the terminal output and log file.
%
% \section{Examples}
%
% \hardwrap{50}{\PackageWarning{foobar}}{\MessageBreak}{^^A
%   Sed feugiat. Cum sociis natoque penatibus et
%   magnis dis parturient montes, nascetur ridiculus mus. Ut
%   pellentesque augue sed urna. Vestibulum diam eros, fringilla et,
%   consectetuer eu, nonummy id, sapien. Nullam at lectus. In sagittis
%   ultrices mauris. Curabitur malesuada erat sit amet massa. Fusce
%   blandit. Aliquam erat volutpat.  Aliquam euismod. Aenean vel lectus.
%   Nunc imperdiet justo nec dolor;}
%
% \PackageWarning{foobar}{^^A
%   Sed feugiat. Cum sociis natoque penatibus et
%   magnis dis parturient montes, nascetur ridiculus mus. Ut
%   pellentesque augue sed urna. Vestibulum diam eros, fringilla et,
%   consectetuer eu, nonummy id, sapien. Nullam at lectus. In sagittis
%   ultrices mauris. Curabitur malesuada erat sit amet massa. Fusce
%   blandit. Aliquam erat volutpat.  Aliquam euismod. Aenean vel lectus.
%   Nunc imperdiet justo nec dolor;}
%
% The command
% \begin{verbatim}
% \hardwrap{50}{\PackageWarning{foobar}}{\MessageBreak}{^^A
%   Sed feugiat. Cum sociis natoque...;}
% \end{verbatim}
% produces the following in the console output:
% \begin{verbatim}
%Package foobar Warning: Sed feugiat. Cum sociis natoque penatibus et magnis
%(foobar)                dis parturient montes, nascetur ridiculus mus. Ut
%(foobar)                pellentesque augue sed urna. Vestibulum diam eros,
%(foobar)                fringilla et, consectetuer eu, nonummy id, sapien.
%(foobar)                Nullam at lectus. In sagittis ultrices mauris.
%(foobar)                Curabitur malesuada erat sit amet massa. Fusce
%(foobar)                blandit. Aliquam erat volutpat. Aliquam euismod.
%(foobar)                Aenean vel lectus. Nunc imperdiet justo nec
%(foobar)                dolor; on input line 102.
% \end{verbatim}
% Compare this to that below without the manual wrapping; \TeX\ breaks lines at 79 characters without keeing words together; e.g., `Vestibulum' broken between lines two and three
% \begin{verbatim}
%Package foobar Warning: Sed feugiat. Cum sociis natoque penatibus et magnis dis
% parturient montes, nascetur ridiculus mus. Ut pellentesque augue sed urna. Ves
%tibulum diam eros, fringilla et, consectetuer eu, nonummy id, sapien. Nullam at
% lectus. In sagittis ultrices mauris. Curabitur malesuada erat sit amet massa. 
%Fusce blandit. Aliquam erat volutpat. Aliquam euismod. Aenean vel lectus. Nunc 
%imperdiet justo nec dolor; on input line 110.
% \end{verbatim}
%
% \newpage
% \part{Implementation of \textsf{\jobname}}
%\iffalse
%<*package>
%\fi
% This is the package implementation.
%
% \section{Required Packages}
%    \begin{macrocode}
\RequirePackage{calc,ifmtarg,ifplatform}
%    \end{macrocode}
%
%
% \section{Counters and variables}
% \begin{macro}{\hw@charcount}
% \begin{macro}{\hw@wordcount}
% The \cs{hw@charcount} count holds the number of characters on the current
% line.  The \cs{hw@wordcount} count holds the number of characters in the current word.
%    \begin{macrocode}
\newcount\hw@charcount
\hw@charcount=-1\relax
%    \end{macrocode}
%
%    \begin{macrocode}
\newcount\hw@wordcount
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hw@currtext}
% \begin{macro}{\hw@currline}
% \begin{macro}{\hw@currword}
% We store the current word, current line, and current wrapped text in the
% following macros:
%    \begin{macrocode}
\def\hw@currtext{}
\def\hw@currline{}
\def\hw@currword{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hw@newline}
% This macro is called each time a line break is created.  It typically holds
% \cs{MessageBreak} for log messages, but could be set to \cs{\char`\\} for typeset
% text.
%    \begin{macrocode}
\protected\def\hw@newline{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@space}
% This definition of `space' is design to be switched for a real space later on.
%    \begin{macrocode}
\protected\def\hw@space{ }
\def\hw@expanding@space{ }
\let\hw@kernel@space\space
%    \end{macrocode}
% \end{macro}
%
% \section{Main procedure}
%
% \begin{macro}{\hardwrap}
%    \begin{macrocode}
\newcommand\hardwrap[4]{%
  \begingroup
    \hw@maxprintline=#1\relax
    \let\space\hw@space
    \let\ \hw@space
    \edef\@tempa{#4}%
    \expandafter\hw@scan\@tempa\hw@scanstop
    \def\hw@newline{#3}
    \let\space\hw@kernel@space
    #2{\hw@wrappedtext}
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@scan}
%    \begin{macrocode}
\def\hw@scan{%
  \futurelet\let@token\hw@process
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@scanstop}
% This is a `quark' from expl3; it will never be executed, else an infinite loop results.
%    \begin{macrocode}
\def\hw@scanstop{\hw@scanstop}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@process}
% The \cs{hw@process} macro contains the actual word-wrapping algorithm.
% The text is scanned token by token.  Each token falls into one of three
% categories: (a)~the stop token \cs{hw@scanstop}, (b)~a space token, or
% (c)~anything else.
%
%    \begin{macrocode}
\def\hw@process{%
%    \end{macrocode}
% If we encounter the \cs{hw@scanstop} token, then we've hit the end of the
% string. Swallow the stop token and stop processing.
%    \begin{macrocode}
  \ifx\let@token\hw@scanstop\relax
    \hw@process@end
    \let\next\@gobble
%    \end{macrocode}
% If we find a space, add the word to the current line if it fits, otherwise
% insert a line break and put the word on its own line.  Continue reading tokens.
%    \begin{macrocode}
  \else
    \ifx\let@token\@sptoken
      \ifnum\numexpr(\hw@charcount+\hw@wordcount+1)\relax<\hw@maxprintline\relax
        \advance\hw@charcount by \hw@wordcount
        \ifx\hw@currline\@empty
          \protected@edef\hw@currline{\hw@currword}%
        \else
          \advance\hw@charcount by 1\relax % account for the space character
          \protected@edef\hw@currline{\hw@currline\hw@expanding@space\hw@currword}%
        \fi
      \else
        \hw@charcount=\hw@wordcount\relax
        \protected@edef\hw@currtext{\hw@currtext\hw@currline\hw@newline}%
        \let\hw@currline\hw@currword
      \fi
      \hw@wordcount=1\relax
      \let\hw@currword\@empty
      \let\next\hw@dochar
%    \end{macrocode}
% If the token is neither the stop token nor a space, we'll just append it to
% the current word and continue reading tokens.
%    \begin{macrocode}
    \else
      \advance\hw@wordcount by 1\relax
      \let\next\hw@dochar
    \fi
  \fi
  \next
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@dochar}
% After a letter, the \cs{hw@dochar} macro just appends a token (non-space and non-stop token) to the current word.
% After a space token, however, the following argument could possibly be \cs{hw@scanstop}, so we need to special-case this branch. I have a feeling that a `gobble-space' function is possible which would make this all a bit more elegant but this works for now.
%    \begin{macrocode}
\def\hw@dochar#1{%
  \def\@tempa{#1}%
  \ifx\@tempa\hw@scanstop
    \hw@process@end
  \else
    \protected@edef\hw@currword{\hw@currword#1}%
    \expandafter\hw@scan
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@process@end}
% The final stage of processing the text. We've just come to the end of the final
% word on the final line: add the word to the current line if it fits, otherwise insert a line
% break and put the word on its own line.
%    \begin{macrocode}
\def\hw@process@end{%
    \ifnum\numexpr(\hw@charcount+\hw@wordcount+1)\relax<\hw@maxprintline\relax
      \protected@edef\hw@wrappedtext{%
        \hw@currtext
        \ifx\hw@currline\@empty\else
          \hw@currline\space
        \fi
        \hw@currword
      }%
    \else
      \protected@edef\hw@wrappedtext{%
        \hw@currtext\hw@currline\hw@newline\hw@currword
      }%
    \fi
}
%    \end{macrocode}
% \end{macro}
%
% \section{Utility Macros}
%
% \begin{macro}{\hw@strlen}
% A simple string-length macro.
%
%    \begin{macrocode}
\def\hw@END{\hw@END}
\def\hw@strlen#1{%
 \number\numexpr\hw@Ncharscan#1\hw@END\relax
}
\def\hw@Ncharscan#1{%
 \ifx#1\hw@END
   \expandafter\@gobble
 \else
   \expandafter\@firstofone
 \fi
 {+1\hw@Ncharscan}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hw@maxprintline}
% Some code to detect \TeX's \textit{max\_print\_line} value.
% This doesn't work with MiKTeX (yet?), so we disable it under Windows always.
%    \begin{macrocode}
\newcount\hw@maxprintline
\ifwindows\else
  \ifnum\pdfshellescape>0\relax
    \hw@maxprintline=\@@input"|kpsewhich -var-value=max_print_line"\relax
  \fi
\fi
\ifnum\hw@maxprintline=0\relax % default
  \hw@maxprintline=79\relax % default
\fi
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setmaxprintline}
% In case the code above borks the \cs{hw@maxprintline} value, the user can set it manually with the \cs{setmaxprintline} macro.
%    \begin{macrocode}
\newcommand*{\setmaxprintline}[1]{%
  \hw@maxprintline=#1\relax
}
%    \end{macrocode}
% \end{macro}
%
% \section{Wrapping Log Messages}
%
% \LaTeX{} informational, warning, and error messages are printed in the
% format:
% \begin{quote}
%   \ttfamily
%   \begin{tabular}{l@{\space}l}
%     Package \meta{pkgname} Info: & This is an informational message.\\
%     (\meta{pkgname})             & That spans multiple lines. The\\
%     (\meta{pkgname})             & \string\MessageBreak macro is used to split\\
%     (\meta{pkgname})             & the text across lines.\\
%     \leftarrowfill$A$\rightarrowfill & \leftarrowfill$B$\rightarrowfill\\
%     \multicolumn{2}{c}{\leftarrowfill$\textrm{\textit{max\_print\_line}}$\rightarrowfill}
%   \end{tabular}
% \end{quote}
%
% The maximum line length ($\textit{max\_print\_line}$) is used by
% \TeX{} for all log file and terminal output.  It defaults to 79 characters
% but may be changed by editing the \texttt{texmf.cnf} file.
%
% The length of $A$ is the sum of three values:
% \begin{enumerate}
%   \item whether it's a class of package message: add 6 for class messages,
%   and 8 for package messages;
%   \item the length of the package name;
%   \item the type of message: information (add 7), warning (add 10), or error
%   (add 10).
% \end{enumerate}
%
% The length of $B$ is the difference between $\textit{max\_print\_line}$ and
% $A$.
%
% \begin{macro}{hw@info@length}
% \begin{macro}{hw@warning@length}
% \begin{macro}{hw@error@length}
% \begin{macro}{hw@pkgname@length}
% We'll store these calculated values in counters so that we don't have to
% recalculate them each time a message is generated.  (This is a time vs.
% space trade-off.)
%
% Note that the length of $B$ for the warning and error text is the same.
%
% In addition to the above lengths, the \cs{PackageError} macro allows for
% additional text to be displayed when the user requests it.  This text
% doesn't have anything prepended to each line, so the length of this text is
% the same as $\textit{max\_print\_line} - 1$.
%
%    \begin{macrocode}
\newcounter{hw@info@length}% info text
\newcounter{hw@warning@length}% warning and error text
\newcounter{hw@error@length}% extended error help text
\newcounter{hw@pkgname@length}% length of package/class name
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\GeneratePackageLogMacros}
% \begin{macro}{\GenerateClassLogMacros}
% Shortcuts are provided for generating logging macros that automatically wrap
% the text provided to them.  The \cs{GeneratePackageLogMacros} and
% \cs{GenerateClassLogMacros} calculate the various lengths of $B$ and set the
% counters appropriately.  Then \cs{hw@generate@logging@macros} is called to,
% well, generate the logging macros.
%
%    \begin{macrocode}
\newcommand{\GeneratePackageLogMacros}[2][]{%
  \setcounter{hw@pkgname@length}{\hw@strlen{#2}}%
  \setcounter{hw@info@length}
    {\the\hw@maxprintline-\value{hw@pkgname@length}-16}%
  \setcounter{hw@warning@length}
    {\the\hw@maxprintline-\value{hw@pkgname@length}-19}%
  \setcounter{hw@error@length}{\the\hw@maxprintline-1}%
  \let\hw@info\PackageInfo
  \let\hw@warning\PackageWarning
  \let\hw@error\PackageError
  \hw@generate@logging@macros{#1}{#2}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\GenerateClassLogMacros}[2][]{%
  \setcounter{hw@pkgname@length}{\hw@strlen{#2}}%
  \setcounter{hw@info@length}
    {\the\hw@maxprintline-\value{hw@pkgname@length}-14}%
  \setcounter{hw@warning@length}
    {\the\hw@maxprintline-\value{hw@pkgname@length}-17}%
  \setcounter{hw@error@length}{\the\hw@maxprintline-1}%
  \let\hw@info\ClassInfo
  \let\hw@warning\ClassWarning
  \let\hw@error\ClassError
  \hw@generate@logging@macros{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hw@generate@logging@macros}
% And now for the code that generates all the logging macros:
%    \begin{macrocode}
\newcommand{\hw@generate@logging@macros}[2]{%
  \@ifmtarg{#1}{
    \hw@generate@logging@macros@aux{#2}{#2}
  }{
    \hw@generate@logging@macros@aux{#1}{#2}
  }
}
\newcommand{\hw@generate@logging@macros@aux}[2]{%
  \expandafter\newcommand\csname #1@info\endcsname[1]{%
    \hardwrap{\value{hw@info@length}}{\xdef\hw@tempa}{\MessageBreak}{##1}%
    \hw@info{#2}{\hw@tempa^^JThis message occurred}%
  }%
  \expandafter\newcommand\csname #1@info@noline\endcsname[1]{%
    \hardwrap{\value{hw@info@length}}{\xdef\hw@tempa}{\MessageBreak}{##1}%
    \hw@info{#2}{\hw@tempa\@gobble}%
  }%
  \expandafter\newcommand\csname #1@warning\endcsname[1]{%
    \hardwrap{\value{hw@warning@length}}{\xdef\hw@tempa}{\MessageBreak}{##1}%
    \hw@warning{#2}{\hw@tempa^^JThis warning occurred}%
  }%
  \expandafter\newcommand\csname #1@warning@noline\endcsname[1]{%
    \hardwrap{\value{hw@warning@length}}{\xdef\hw@tempa}{\MessageBreak}{##1}%
    \hw@warning{#2}{\hw@tempa\@gobble}%
  }%
  \expandafter\newcommand\csname #1@error\endcsname[2]{%
    \hardwrap{\value{hw@warning@length}}{\xdef\hw@tempa}{\MessageBreak}{##1}%
    \hardwrap{\value{hw@error@length}}{\xdef\hw@tempb}{\MessageBreak}{##2}%
    \hw@error{#2}{\hw@tempa}{\hw@tempb}%
  }%
}%
%    \end{macrocode}
% \end{macro}
%
% Fin.
%
%\iffalse
%</package>
%\fi
%
% \Finale
%
% \typeout{*************************************************************}
% \typeout{*}
% \typeout{* To finish the installation you have to move the following}
% \typeout{* file into a directory searched by TeX:}
% \typeout{*}
% \typeout{* \space\space\space hardwrap.sty}
% \typeout{*}
% \typeout{*************************************************************}
%
\endinput

